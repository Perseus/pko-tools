import { readFileSync } from "fs";
import { resolve } from "path";
import { describe, expect, test } from "vitest";
import type { EffectFile } from "@/types/effect";

/**
 * Schema sync test: validates that the JSON fixture generated by the Rust
 * backend (`cargo test generate_frontend_fixture`) matches the TypeScript
 * EffectFile interface. This catches type drift between backend and frontend.
 *
 * The fixture is generated by: src-tauri/tests/effect_schema_sync_test.rs
 */

const fixturePath = resolve(__dirname, "fixtures/known_effect.json");

function loadFixture(): EffectFile {
  const json = readFileSync(fixturePath, "utf8");
  return JSON.parse(json) as EffectFile;
}

describe("backend JSON matches frontend EffectFile type", () => {
  const data = loadFixture();

  test("top-level fields have correct types", () => {
    expect(typeof data.version).toBe("number");
    expect(typeof data.idxTech).toBe("number");
    expect(typeof data.usePath).toBe("boolean");
    expect(typeof data.pathName).toBe("string");
    expect(typeof data.useSound).toBe("boolean");
    expect(typeof data.soundName).toBe("string");
    expect(typeof data.rotating).toBe("boolean");
    expect(typeof data.rotaVel).toBe("number");
    expect(typeof data.effNum).toBe("number");
  });

  test("rotaVec is a Vec3", () => {
    expect(Array.isArray(data.rotaVec)).toBe(true);
    expect(data.rotaVec).toHaveLength(3);
    for (const v of data.rotaVec) {
      expect(typeof v).toBe("number");
    }
  });

  test("subEffects is an array with correct count", () => {
    expect(Array.isArray(data.subEffects)).toBe(true);
    expect(data.subEffects.length).toBe(data.effNum);
  });

  test("sub-effect scalar fields have correct types", () => {
    for (const sub of data.subEffects) {
      expect(typeof sub.effectName).toBe("string");
      expect(typeof sub.effectType).toBe("number");
      expect(typeof sub.srcBlend).toBe("number");
      expect(typeof sub.destBlend).toBe("number");
      expect(typeof sub.length).toBe("number");
      expect(typeof sub.frameCount).toBe("number");
      expect(typeof sub.verCount).toBe("number");
      expect(typeof sub.coordCount).toBe("number");
      expect(typeof sub.coordFrameTime).toBe("number");
      expect(typeof sub.texCount).toBe("number");
      expect(typeof sub.texFrameTime).toBe("number");
      expect(typeof sub.texName).toBe("string");
      expect(typeof sub.modelName).toBe("string");
      expect(typeof sub.billboard).toBe("boolean");
      expect(typeof sub.vsIndex).toBe("number");
      expect(typeof sub.segments).toBe("number");
      expect(typeof sub.height).toBe("number");
      expect(typeof sub.topRadius).toBe("number");
      expect(typeof sub.botRadius).toBe("number");
      expect(typeof sub.frameTexCount).toBe("number");
      expect(typeof sub.frameTexTime).toBe("number");
      expect(typeof sub.frameTexTime2).toBe("number");
      expect(typeof sub.useParam).toBe("number");
      expect(typeof sub.rotaLoop).toBe("boolean");
      expect(typeof sub.alpha).toBe("boolean");
      expect(typeof sub.rotaBoard).toBe("boolean");
    }
  });

  test("frame arrays have correct length matching frameCount", () => {
    for (const sub of data.subEffects) {
      const n = sub.frameCount;
      expect(sub.frameTimes).toHaveLength(n);
      expect(sub.frameSizes).toHaveLength(n);
      expect(sub.frameAngles).toHaveLength(n);
      expect(sub.framePositions).toHaveLength(n);
      expect(sub.frameColors).toHaveLength(n);
    }
  });

  test("frame vectors have correct dimensions", () => {
    for (const sub of data.subEffects) {
      for (const size of sub.frameSizes) {
        expect(size).toHaveLength(3); // Vec3
      }
      for (const angle of sub.frameAngles) {
        expect(angle).toHaveLength(3); // Vec3
      }
      for (const pos of sub.framePositions) {
        expect(pos).toHaveLength(3); // Vec3
      }
      for (const color of sub.frameColors) {
        expect(color).toHaveLength(4); // Vec4
      }
    }
  });

  test("rotaLoopVec is a Vec4", () => {
    for (const sub of data.subEffects) {
      expect(Array.isArray(sub.rotaLoopVec)).toBe(true);
      expect(sub.rotaLoopVec).toHaveLength(4);
    }
  });

  test("frameTexNames is a string array matching frameTexCount", () => {
    for (const sub of data.subEffects) {
      expect(Array.isArray(sub.frameTexNames)).toBe(true);
      expect(sub.frameTexNames.length).toBe(sub.frameTexCount);
      for (const name of sub.frameTexNames) {
        expect(typeof name).toBe("string");
      }
    }
  });

  test("perFrameCylinder has correct shape when present", () => {
    for (const sub of data.subEffects) {
      expect(Array.isArray(sub.perFrameCylinder)).toBe(true);
      if (sub.useParam > 0) {
        expect(sub.perFrameCylinder.length).toBe(sub.frameCount);
      }
      for (const cyl of sub.perFrameCylinder) {
        expect(typeof cyl.segments).toBe("number");
        expect(typeof cyl.height).toBe("number");
        expect(typeof cyl.topRadius).toBe("number");
        expect(typeof cyl.botRadius).toBe("number");
      }
    }
  });

  test("coord and tex lists have correct nesting", () => {
    for (const sub of data.subEffects) {
      expect(Array.isArray(sub.coordList)).toBe(true);
      if (sub.coordCount > 0) {
        expect(sub.coordList.length).toBe(sub.coordCount);
        for (const frame of sub.coordList) {
          expect(frame.length).toBe(sub.verCount);
          for (const uv of frame) {
            expect(uv).toHaveLength(2); // Vec2
          }
        }
      }
      expect(Array.isArray(sub.texList)).toBe(true);
    }
  });

  test("blend values are within valid D3DBLEND range (1-17)", () => {
    for (const sub of data.subEffects) {
      expect(sub.srcBlend).toBeGreaterThanOrEqual(1);
      expect(sub.srcBlend).toBeLessThanOrEqual(17);
      expect(sub.destBlend).toBeGreaterThanOrEqual(1);
      expect(sub.destBlend).toBeLessThanOrEqual(17);
    }
  });

  test("effectType is a valid enum value (0-4)", () => {
    for (const sub of data.subEffects) {
      expect(sub.effectType).toBeGreaterThanOrEqual(0);
      expect(sub.effectType).toBeLessThanOrEqual(4);
    }
  });

  test("no unexpected keys in top-level object", () => {
    const expectedKeys = new Set([
      "version", "idxTech", "usePath", "pathName", "useSound",
      "soundName", "rotating", "rotaVec", "rotaVel", "effNum", "subEffects",
    ]);
    for (const key of Object.keys(data)) {
      expect(expectedKeys.has(key)).toBe(true);
    }
  });

  test("no unexpected keys in sub-effect objects", () => {
    const expectedKeys = new Set([
      "effectName", "effectType", "srcBlend", "destBlend", "length",
      "frameCount", "frameTimes", "frameSizes", "frameAngles",
      "framePositions", "frameColors", "verCount", "coordCount",
      "coordFrameTime", "coordList", "texCount", "texFrameTime",
      "texName", "texList", "modelName", "billboard", "vsIndex",
      "segments", "height", "topRadius", "botRadius", "frameTexCount",
      "frameTexTime", "frameTexNames", "frameTexTime2", "useParam",
      "perFrameCylinder", "rotaLoop", "rotaLoopVec", "alpha", "rotaBoard",
    ]);
    for (const sub of data.subEffects) {
      for (const key of Object.keys(sub)) {
        expect(expectedKeys.has(key)).toBe(true);
      }
    }
  });
});
